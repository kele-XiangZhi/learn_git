Gc算法和堆内存关系。

GC相关：
GC算法是对虚拟机中的内存堆得管理。
GC目前主要常用的4中：串行，并行，cms，G1.
串行： 简单说就是一个CPU,单项执行，需要的STW时间长。
并行： 多Cpu同时执行GC，放弃系统或者程序的执行。
CMS: 	并发GC，特点是保有系统和JVM的执行。一定百分比的执行GC。吞吐下降。
G1: 增量式GC，CMS GC的优化。把内存分为多个小块，有限去GC 对象多的内存块。减少STW。可以设置最小的暂停时间。


堆相关：
堆；是虚拟机中存储数据的地方。根据分类会形成年轻代（新生代，S0,S1）和老年代。
新生代是系统读取文件刚创建的数据存放的地方，在经过GC的标记-复制算法之后，会把。数据放在没有数据的另一个存活区，删除原有的新生代和有数据的存活跃区域。所以成为标记-复制
老年代因为没必要去进行数据合并，所以直接是标记-删除。如果有必要还会标记-整理-删除。

标记的方法是找到活跃的数据进行标记，标识这个数据还被使用，使用次数加减标识正在被使用。
遇到循环的标记对象，需要根链接对象。也就是类似树形结构一样的能够识别被引用。


GC和堆得粗关系：
Jvm读取字节码文件，根据文件创建对象，占据内存。分别创建堆，栈，方法区。
堆中存储的是数据。一般相对比较大。默认根绝Jvm的配置进行，堆中空间分配。
刚创建的数据放入堆得年轻代中的新生代区。等新生代满了或者是主动调用，或者是满足了出发YGC的内存百分比，进行调用。
调用后，标记-复制，存入S0 S1,多次被YGC后仍存在的数据，一般15此。会放入老年代。进行OldGC。
老年代满了或者主动触发 或者是满足百分比，就继续宁Full GC.

CMS和G1的算法：大体上可以理解为 1.新生代停顿标识，2.3老年代标识，存活和脏数据 4.5执行并发的标记和清除。6.并发重置


不同GC与堆的关系：
串行：
串行适用与小内存，单CPU的环境。他对堆得支撑一般在几百MB的范围内。有很高的STW.
年轻代算法：标记-复制；老年代算法：标记-清除-整理。

并行：
并行适用于多核CPU，用来提高执行GC的效率，吞吐量变大。
年轻代算法：标记-复制；老年代算法：标记-清除-整理。

cms:
cms在不影响系统的运行的情况下，并行执行GC。延迟上会感官好。
年轻代算法：标记-复制；老年代算法：标记-清除。
4个以内内存。

G1：
G1是把内存不固定的把内存区分成一般2048个内存块，在CMS的基础上在进行的优化。
也就是并发+增量。收集新老代后，进行小块执行，减少了STW。更大的减少了延迟感。
适用4G以上内存。

